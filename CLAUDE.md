- This is the source of the R-ArcGIS Bridge package {clacite} which provides bindings to Esri Calcite Design System components.
- The components were originally automatically generated by data-raw/generate-component-new.R
- The auto-generated shiny bindings are created via inst/www/calcite-bindings.js
- We are in the process of re-writing them manually.

## Banned actions

You are banned from performing the below actions. 

- Running any shell commands without permission
- Calling R in any way shape or form
- Using Git for committing, pushing, or merging


## Creating new components

When creating a new component:

- remove the component from R/components-generated.R
- remove the binding from inst/www/calcite-bindings.js
- remove the component from the "Generated Components" section in `_pkgdown.yml` and add it to the appropriate named section
- create a new binding inst/www/calcite-{component}.js
- add the binding using `htmltools::htmlDependency()` 


R/action.R example: 
```
  action_binding <- htmltools::htmlDependency(
    name = "calcite-action-binding",
    version = calcite_version(),
    src = c(file = system.file("www", package = "calcite")),
    script = "calcite-action.js"
  )
```

- Component properties (except read-only) must be arguments
- Component slots must be arguments and MUST use `add_slot()` helper - see R/panel.R for reference
- Ignore all deprecated properties and slots
- Bindings must register each event
- Use `compact()` to remove NULL items from slot content lists (not just attribute lists)
- **Always initialize input values on component ready** using the `componentOnReady` pattern so Shiny receives the full state immediately (not just on first interaction). See `inst/www/calcite-action.js` and `inst/www/calcite-checkbox.js` for the canonical pattern:

```js
const initializeValue = function() {
  const initialValue = binding.getValue(el);
  Shiny.setInputValue(el.id, initialValue);
};

if (el.componentOnReady) {
  el.componentOnReady().then(initializeValue);
} else {
  setTimeout(initializeValue, 100);
}
```

- New components must have a `inst/examples/calcite-{component}.R` file based on calcite JS examples
  - **Always include `devtools::load_all()` at the top of each example**
  - **Only create `verbatimTextOutput()` for components that have reactive state or emit events**
  - Create separate `verbatimTextOutput()` for each component with reactive state
  - In `renderPrint()`, display the raw reactive value directly: `input$component_id`
  - **NEVER construct custom lists or extract specific properties** - show the full reactive object as-is
  - Reference `inst/examples/calcite-checkbox.R` as the pattern to follow
  - **Layout pattern:** Use `calcite_shell(panel_start = calcite_panel(...), calcite_panel(...))` â€” pass `calcite_panel` directly to `panel_start`/`panel_end`, no need for `calcite_shell_panel` wrapper
  - Put components inside a `calcite_block` (collapsible, expanded = TRUE) inside the left `calcite_panel`
  - Put each `verbatimTextOutput()` inside its own `calcite_block` (collapsible, expanded = TRUE) inside the right `calcite_panel`
  - Use `h3()` labels above outputs only when NOT using `calcite_block` (the block heading serves as the label)


## JS binding patterns

### `update_calcite()` sends arrays
`update_calcite()` wraps values in a list, so data arrives as an array in JS `receiveMessage`. Always unwrap:
```js
const value = Array.isArray(data) ? data[0] : data;
```

## Argument validation

Use `rlang` functions to check types and values, and `cli` to emit errors:

- String values with fixed options: `rlang::arg_match(arg, c("a", "b", "c"))`
- Scalar logical: `rlang::is_scalar_logical(arg)` + `cli::cli_abort("{.arg arg} must be a scalar logical.")`
- Other type checks: prefer `rlang::is_scalar_*()` helpers over `is.*()` base R equivalents

## Etiquette

- Never run R code, ask me to.
- Use `compact()` to remove NULL elements from a list
- Use `rlang::arg_match()` to validate input string values